import{_ as e,c as o,o as c,V as d}from"./chunks/framework.e9ed5590.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blog/frontend/base.md","filePath":"blog/frontend/base.md"}'),a={name:"blog/frontend/base.md"},l=d('<h2 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h2><ul><li><code>javascript</code> 是一门通过原型实现继承的语言。原型就是给其他对象提供共有属性的对象。</li><li>每个 <code>函数</code> 都有一个名为 <code>prototype</code> 的属性，它指向的是一个 <code>prototype</code>对象。</li><li>每个对象都有一个 <code>[[prototype]]</code> 的隐式引用，它指向它的原型对象，并从中继承数据和方法等，而原型对象也是对象，也会有 <code>[[prototype]]</code> 的隐式引用， 这样一层一层，最终指向 <code>null</code>，这种关系就是原型链。</li></ul><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><ol><li>什么是 <code>闭包</code></li></ol><ul><li><code>闭包</code> 就是能够访问到其他函数内部变量的函数。</li></ul><ol start="2"><li><code>闭包</code> 的作用</li></ol><ul><li>隐藏一个变量。</li><li>延长变量的声明周期。</li></ul><h2 id="vue-生命周期" tabindex="-1">vue 生命周期 <a class="header-anchor" href="#vue-生命周期" aria-label="Permalink to &quot;vue 生命周期&quot;">​</a></h2><ul><li>生命周期之间是不会产生阻塞的，比如在 <code>created</code> 钩子函数前添加 <code>async</code>，在函数中调用异步请求，在 <code>mounted</code> 中并不一定能拿到异步请求的结果。</li><li>可以在 <code>created</code> 钩子中，在异步请求完成后使用 <code>this.$emit(xxx)</code>，然后在 <code>mounted</code> 中使用 <code>this.$on(xxx)</code> 来监听，这样一定能获取到异步请求的结果。</li></ul><h2 id="vite-和-webpack" tabindex="-1">vite 和 webpack <a class="header-anchor" href="#vite-和-webpack" aria-label="Permalink to &quot;vite 和 webpack&quot;">​</a></h2><ul><li><code>vite</code> 利用了浏览器的原生 <code>ESModlue</code> 功能，在浏览器请求相应 URL 时才提供文件，实现了根据路由的懒加载。</li><li>对比于 <code>webpack</code> 的热更新，<code>webpack</code> 会把所有改动过的模块的相关依赖全部重新编译一次。</li><li><code>vite</code> 的 <code>unbundle</code> 机制在 <code>devServer</code> 取得巨大的性能提升，但是首屏和懒加载的性能有所下降。</li></ul><h2 id="webpack-的工作流程" tabindex="-1">webpack 的工作流程 <a class="header-anchor" href="#webpack-的工作流程" aria-label="Permalink to &quot;webpack 的工作流程&quot;">​</a></h2><ul><li>从入口文件开始，递归的进行解析依赖的所有模块，每找到一个模块，都会去寻找对应的<code>loader</code> 进行转换，对模块转换完毕之后，再开始解析当前模块所依赖的模块。</li><li>这些模块会以入口为单位进行分组，一个入口和其所依赖的模块分到一个组(<code>chunk</code>)，最后 <code>webpack</code> 会将所有的 <code>chunk</code> 转换成文件进行输出。</li><li><code>webpack</code> 会在适当的时机执行 <code>plugin</code> 中定义的逻辑(事件机制)。</li></ul>',13),t=[l];function i(r,n,s,u,h,p){return c(),o("div",null,t)}const k=e(a,[["render",i]]);export{_ as __pageData,k as default};

import{_ as e,c as o,o as t,V as c}from"./chunks/framework.9ad71fd6.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blog/frontend/base.md"}'),d={name:"blog/frontend/base.md"},a=c('<h2 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h2><ul><li><code>javascript</code> 是一门通过原型实现继承的语言。原型就是给其他对象提供共有属性的对象。</li><li>每个 <code>函数</code> 都有一个名为 <code>prototype</code> 的属性，它指向的是一个 <code>prototype</code>对象。</li><li>每个对象都有一个 <code>[[prototype]]</code> 的隐式引用，它指向它的原型对象，并从中继承数据和方法等，而原型对象也是对象，也会有 <code>[[prototype]]</code> 的隐式引用， 这样一层一层，最终指向 <code>null</code>，这种关系就是原型链。</li></ul><h2 id="vue-生命周期" tabindex="-1">vue 生命周期 <a class="header-anchor" href="#vue-生命周期" aria-label="Permalink to &quot;vue 生命周期&quot;">​</a></h2><ul><li>生命周期之间是不会产生阻塞的，比如在 <code>created</code> 钩子函数前添加 <code>async</code>，在函数中调用异步请求，在 <code>mounted</code> 中并不一定能拿到异步请求的结果。</li><li>可以在 <code>created</code> 钩子中，在异步请求完成后使用 <code>this.$emit(xxx)</code>，然后在 <code>mounted</code> 中使用 <code>this.$on(xxx)</code> 来监听，这样一定能获取到异步请求的结果。</li></ul>',4),r=[a];function i(l,n,s,_,p,u){return t(),o("div",null,r)}const f=e(d,[["render",i]]);export{m as __pageData,f as default};

## 原型和原型链

- `javascript` 是一门通过原型实现继承的语言。原型就是给其他对象提供共有属性的对象。
- 每个 `函数` 都有一个名为 `prototype` 的属性，它指向的是一个 `prototype`对象。
- 每个对象都有一个 `[[prototype]]` 的隐式引用，它指向它的原型对象，并从中继承数据和方法等，而原型对象也是对象，也会有 `[[prototype]]` 的隐式引用，
  这样一层一层，最终指向 `null`，这种关系就是原型链。

## 闭包

1. 什么是 `闭包`

- `闭包` 就是能够访问到其他函数内部变量的函数。

2. `闭包` 的作用

- 隐藏一个变量。
- 延长变量的生命周期。

## vue 生命周期

- 生命周期之间是不会产生阻塞的，比如在 `created` 钩子函数前添加 `async`，在函数中调用异步请求，在 `mounted` 中并不一定能拿到异步请求的结果。
- 可以在 `created` 钩子中，在异步请求完成后使用 `this.$emit(xxx)`，然后在 `mounted` 中使用 `this.$on(xxx)` 来监听，这样一定能获取到异步请求的结果。

## vite 和 webpack

- `vite` 利用了浏览器的原生 `ESModlue` 功能，在浏览器请求相应 URL 时才提供文件，实现了根据路由的懒加载。
- 对比于 `webpack` 的热更新，`webpack` 会把所有改动过的模块的相关依赖全部重新编译一次。
- `vite` 的 `unbundle` 机制在 `devServer` 取得巨大的性能提升，但是首屏和懒加载的性能有所下降。

## webpack 的工作流程

- 从入口文件开始，递归的进行解析依赖的所有模块，每找到一个模块，都会去寻找对应的`loader` 进行转换，对模块转换完毕之后，再开始解析当前模块所依赖的模块。
- 这些模块会以入口为单位进行分组，一个入口和其所依赖的模块分到一个组(`chunk`)，最后 `webpack` 会将所有的 `chunk` 转换成文件进行输出。
- `webpack` 会在适当的时机执行 `plugin` 中定义的逻辑(事件机制)。

## http 状态码

- 1xx
  请求已被接受，需要继续处理。

- 2xx
  请求已成功被服务器接收。

  - 200：请求已经成功，请求所希望的响应头或数据体将随此响应返回。
  - 201：请求成功并且服务器创建了新的资源。
  - 202：请求以接受，但是尚未处理。
  - 204：请求已经成功，但是没有内容。

- 3xx
  代表客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址在本次响应的 Location 域中指明。

  - 301：永久重定向。
  - 302：临时重定向。
  - 304：自从上次请求后，请求的网页未被修改过。

- 4xx
  表示请求错误，代表客户端可能发生了错误。

  - 401：请求要求身份验证。
  - 403：服务器已经理解请求，但是拒绝执行它。与 `401` 响应不同的是，身份验证并不能提供任务帮助。
  - 404：未找到资源。

- 5xx
  表示服务器在处理请求的过程中有错误或发生了异常状态。
  - 500：服务器遇到了一个未曾预料的状况，导致它无法完成对请求的处理。
  - 503：临时的服务器维护或者过载，服务器当前无法完成对请求的处理。

## 图形渲染管线

将一堆具有三维信息的数据点最终转换到二位屏幕空间的像素。

1. 顶点处理
   将所有的顶点数据进行 `Model`, `View`, `Projection` 的变换(`MVP变换`)，最终得到二维平面的坐标信息(使用 `ZBuffer`保留深度 z 值)。
2. 三角形处理
   将所有的顶点，按照原几何信息，变成三角面，每个面由三个顶点组成，这样就得到了许许多多的三角形。
3. 光栅化
   把顶点数据转换为片元的过程，确定哪些像素在三角形内。
4. 片元处理
   确定每个像素点或者片元的颜色。(需要顶点的信息，对三角形内的点进行属性插值)(使用 `ZBuffer` 确定哪些像素点应该显示在屏幕上，哪些点被遮挡)
5. `FrameBuffer` 的处理
   将所有的像素颜色信息整合到一起，输送给显示设备加以显示

## Map

```js
const map1 = new Map();
const map2 = new Map([
  ["key", "value"],
  ["key2", "value2"],
]);
map1.set("key", "value");
map1.get("key");
map1.delete("key");
map1.clear();
```

- 与 `Object` 只能使用 `数值`，`字符串` 不同，`Map` 能够使用任何 JS 的数据类型作为键。
- `Map` 实例会维护键值对的插入顺序。
- `Map` 实例可以提供一个 `迭代器`(`Iterator`)，可以通过 `entries` 方法(或者 `Symbol.iterator`) 取得这个迭代器。

## WeakMap

- `WeakMap` 的键只能使 `Object` 或者 继承自 `Object` 的类型。
- 这些键并不属于正式的引用，不会阻止垃圾回收。
- 不可迭代。

## Set

```js
cosnt set = new Set()
set.add(1)
set.has(1)
set.delete(1)
new Set([...array]) //用于数组去重
```

- `Set` 类似于数组，但是成员的值都是唯一的，可以用于数组去重。
- 写入 `Set` 中的数据不会自动转换类型。
- 在 `Set` 中相同的对象并不相等。
- 在 `Set` 中 `NaN` 是相等的。

## WeakSet

- 与 `Set` 类似，区别在于值只能存储对象。
- 不能遍历，多用于存储 `DOM对象`。

## cookie, session, stoken

为了解决 `http` 无状态特性所带来的问题。

### `cookie`

- 是文本数据，形式上是键值对。键值对之间用分号隔开。
- 存储在浏览器。
- 通过 `document.cookie` 可以设置和访问。
- 缺点： 1. 大小被限制在 4K 以内，所以无法保存过多的信息。 2. 容易被劫持和伪造。 3. 会加大传输压力。

### `session`

- 是服务器为了保存用户状态而创建的一个特殊对象。
- 当客户端于服务端第一次建立连接后 ，服务端会创建一个 `session` 对象。此对象有一个 `sessionId`，客户端保存这个 `sessionId` , 在之后的通信中带上这个 `sessionId` , 服务器通过 `sessionId` 就可以找到对应的 `session` , 就可以对客户端进行身份识别并获取一些会话记录！
- `session` 基本上依赖于 `cookie`。
- 缺点： 1. 当一个服务的业务越来越大，无论是分布式还是集群，都可能有这样一个问题：就是 `session` 可能在服务器 A 中创建 ， 但是下一个请求，可能访问了服务器 B 。 但是服务器 B 没有这个 `session` , 也就是对服务器 B 来说 ，此时的请求，它是不认识的！

### `token`

- 用户登录后，服务器颁发给客户端一个令牌。该令牌保存了用户的基本信息和签名等，经过加密后才会发给浏览器。
- 完全由应用所管理，所以能避开 `同源策略`。
- 可以避免 `CSRF` 攻击。
- 能在多个服务器间共享。

## 网络七层模型

- 应用层，表示层，会话层，传输层，网络层，通信链路层，物理层

## 事件循环

- 浏览器是多进程、多线程的应用程序。
- `JavaScript` 是一门单线程语言，运行在浏览器的渲染进程中的渲染主线程中。
- 渲染主线程同时还要负责 `HTML`、`CSS` 等的解析，以及页面的渲染。
- 执行 `JavaScript` 和 渲染 是互斥的，所以不能让 `JavaScript` 长时间的占用渲染主线程。
- 事件队列：在执行 `JavaScript` 时，遇到 `宏任务` 就放入 `宏任务队列`，遇到 `微任务` 就放入 `微任务队列`, 然后渲染主线程继续执行剩下的代码。
- 当渲染主线程执行完后，将从 `微任务队列` 中取出任务继续执行，直到 `微任务队列` 清空，然后从 `宏任务队列` 中取出一个 `宏任务`，执行完后继续清空 `微任务队列`，一直这样循环。
